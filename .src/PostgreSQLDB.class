' Gambas class file

Inherits DBaze

Public host As String
Public port As String
Public dbname As String
Public con As New Connection
Public system_objects As Collection
Public original As String[]

Public Sub _new(host As String, port As String, dbname As String, username As String, password As String, store_password As Boolean)
  Me.host = host
  Me.port = port
  Me.dbname = dbname
  Me.username = username
  Me.password = password
  Me.store_password = store_password
  
  Me.connection_settings["connection type"] = "PostgreSQL"
  Me.connection_settings["host"] = host
  Me.connection_settings["port"] = port
  Me.connection_settings["dbname"] = dbname
  Me.connection_settings["username"] = username
  If Me.store_password Then
    Me.connection_settings["password"] = password
  Endif 
End

Public Sub connect() As Boolean
  ' connect to the database
  With con
    .Type = "postgresql"
    .Host = Me.host
    .Port = Me.port
    .Login = Me.username
    .Password = Me.password
    .Name = Me.dbname
    Try .Open
    If Error Then 
      Message.Info(Error.Text)
      Return False
    End If  
  End With 
  execute("SET client_min_messages TO WARNING;")
  Return True
  
End

Public Function execute(query As String, Optional no_messages As Boolean) As Object[]
  ' execute a query and return the results
  Dim res As Result
  Dim rfield As ResultField
  Dim resultArray As New Object[]
  Dim one_line As Collection
  Dim cmd As String
  Dim context As New Collection
  Dim field_name As String
  Dim counter As Collection
  original = New String[]
  Try con.Exec("ROLLBACK")
  Try res = con.Exec(rewrite_query(query))
  If Error Then 
    If Not no_messages Then
      Message.Info(Error.Text)
    Endif
    Return Null
  Endif
  
  For Each res
    one_line = New Collection
    counter = New Collection
    For Each rfield In res.Fields
      ' here is a bug due to connetion implementation
      ' if there are more than one field with the same name
      ' only the values of the first are displayed
      If counter.Exist(rfield.Name) Then
        counter[rfield.Name] += 1
        field_name = rfield.Name & "_" & Str(counter[rfield.Name])
      Else
        field_name = rfield.Name
        counter[rfield.Name] = 0
      Endif
      context["res"] = res
      cmd = "res!" & rfield.Name
      one_line.Add(Eval(cmd, context), field_name)
    Next
    resultArray.Add(one_line)
  Next
  Return resultArray
End

Public Sub get_db_objects() As Collection
  ' get the database objects (tables, views, indices, functions, triggers, sequences, user defined datatypes)
  Dim objects As New Collection
  Dim tables, views, indices, functions, triggers, sequences, types, languages As String
  Dim row As Object
  tables = "SELECT n.nspname as schema, c.relname as table, CASE c.relkind WHEN 'r' THEN 'table' WHEN 'v' THEN 'view' WHEN 'i' THEN 'index' WHEN 'S' THEN 'sequence' WHEN 's' THEN 'special' WHEN 'f' THEN 'foreign table' END as type, pg_catalog.pg_get_userbyid(c.relowner) as owner FROM pg_catalog.pg_class c LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace WHERE c.relkind IN ('r','') AND n.nspname <> 'pg_catalog' AND n.nspname <> 'information_schema' AND n.nspname !~ '^pg_toast' AND pg_catalog.pg_table_is_visible(c.oid) ORDER BY 1,2"
  views = "SELECT n.nspname as schema, c.relname as view, CASE c.relkind WHEN 'r' THEN 'table' WHEN 'v' THEN 'view' WHEN 'i' THEN 'index' WHEN 'S' THEN 'sequence' WHEN 's' THEN 'special' WHEN 'f' THEN 'foreign table' END as type, pg_catalog.pg_get_userbyid(c.relowner) as owner FROM pg_catalog.pg_class c LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace WHERE c.relkind IN ('v','') AND n.nspname <> 'pg_catalog' AND n.nspname <> 'information_schema' AND n.nspname !~ '^pg_toast' AND pg_catalog.pg_table_is_visible(c.oid) ORDER BY 1,2"
  indices = "SELECT n.nspname as schema, c.relname as index, CASE c.relkind WHEN 'r' THEN 'table' WHEN 'v' THEN 'view' WHEN 'i' THEN 'index' WHEN 'S' THEN 'sequence' WHEN 's' THEN 'special' END as type,  u.usename as owner, c2.relname as table FROM pg_catalog.pg_class c JOIN pg_catalog.pg_index i ON i.indexrelid = c.oid JOIN pg_catalog.pg_class c2 ON i.indrelid = c2.oid LEFT JOIN pg_catalog.pg_user u ON u.usesysid = c.relowner LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace WHERE c.relkind IN ('i','') AND n.nspname NOT IN ('pg_catalog', 'pg_toast') AND pg_catalog.pg_table_is_visible(c.oid) ORDER BY 1,2"
  functions = "SELECT n.nspname as schema, p.proname as function,  pg_catalog.pg_get_function_result(p.oid) as result_data, pg_catalog.pg_get_function_arguments(p.oid) as arguments, CASE WHEN p.proisagg THEN 'agg' WHEN p.proiswindow THEN 'window' WHEN p.prorettype = 'pg_catalog.trigger'::pg_catalog.regtype THEN 'trigger' ELSE 'normal' END as function_type FROM pg_catalog.pg_proc p LEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace WHERE pg_catalog.pg_function_is_visible(p.oid) AND n.nspname <> 'pg_catalog' AND n.nspname <> 'information_schema' ORDER BY 1, 2, 4"
  triggers = "SELECT DISTINCT trigger_name AS trigger, event_object_table AS table FROM INFORMATION_SCHEMA.triggers WHERE trigger_schema='public';"
  sequences = "SELECT n.nspname as schema, c.relname as sequence, CASE c.relkind WHEN 'r' THEN 'table' WHEN 'v' THEN 'view' WHEN 'i' THEN 'index' WHEN 'S' THEN 'sequence' WHEN 's' THEN 'special' WHEN 'f' THEN 'foreign table' END as type, pg_catalog.pg_get_userbyid(c.relowner) as owner FROM pg_catalog.pg_class c LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace WHERE c.relkind IN ('S','') AND n.nspname <> 'pg_catalog' AND n.nspname <> 'information_schema' AND n.nspname !~ '^pg_toast' AND pg_catalog.pg_table_is_visible(c.oid) ORDER BY 1,2"
  types = "SELECT n.nspname as schema,   pg_catalog.format_type(t.oid, NULL) AS user_type, pg_catalog.obj_description(t.oid, 'pg_type') as description FROM pg_catalog.pg_type t LEFT JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace WHERE (t.typrelid = 0 OR (SELECT c.relkind = 'c' FROM pg_catalog.pg_class c WHERE c.oid = t.typrelid)) AND NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type el WHERE el.oid = t.typelem AND el.typarray = t.oid) AND n.nspname <> 'pg_catalog' AND n.nspname <> 'information_schema' AND pg_catalog.pg_type_is_visible(t.oid) ORDER BY 1, 2;"
  languages = "SELECT l.lanname AS language, pg_catalog.pg_get_userbyid(l.lanowner) as owner, l.lanpltrusted AS trusted FROM pg_catalog.pg_language l WHERE lanplcallfoid != 0  ORDER BY 1"
  
  objects["tables"] = execute(tables)
  objects["views"] = execute(views)
  objects["indices"] = execute(indices)
  objects["functions"] = execute(functions)
  objects["triggers"] = execute(triggers)
  objects["sequences"] = execute(sequences)
  objects["types"] = execute(types)
  objects["languages"] = execute(languages)
  
  objects["attributes"] = New Collection
  For Each row In objects["tables"]
    objects["attributes"][row["table"]] = execute("SELECT a.attname as attribute, a.attnum FROM pg_catalog.pg_attribute a WHERE a.attrelid = (SELECT c.oid FROM pg_catalog.pg_class c LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace WHERE c.relname = '" & row["table"] & "' AND pg_catalog.pg_table_is_visible(c.oid)) AND a.attnum > 0 AND NOT a.attisdropped ORDER BY a.attnum")
  Next
  
  objects["object types"] = [ 
    "tables": "table.png", 
    "views": "view.png", 
    "indices": "index.png", 
    "functions": "function.png", 
    "triggers": "trigger.png", 
    "sequences": "sequence.png",
    "types": "data_type.png"]
  Return objects
End

Public Sub initialize_gui()
  ' initialize the GUI for PostgreSQL database
  'Dim documentation As New WebView(FMain.main_tabstrip)
  Dim data_definition As FormPostgreSQLDataDefinition
  Dim data_manipulation As FormPostgreSQLDataManipulation
  Dim data_querying As FormPostgreSQLDataQuerying
  
  ' create a dummy tab 
  FMain.main_tabstrip.Text = "PostgreSQL Database - " & Me.dbname
  'documentation.Frame.Url = "test.html" '"http://autopoiesis.foi.hr/wiki.php?name=Baze+Podataka+-+FOI#Teorija baza podataka"
  
  ' create the treeview
  ' first get objects from the database
  refresh_db_tree()
  
  ' create the tool panel
  data_definition = New FormPostgreSQLDataDefinition(FMain.main_toolpanel)
  FMain.main_toolpanel.Index = 1
  data_manipulation = New FormPostgreSQLDataManipulation(FMain.main_toolpanel)
  FMain.main_toolpanel.Index = 2
  data_querying = New FormPostgreSQLDataQuerying(FMain.main_toolpanel)
  
  ' show the data definition tab
  FMain.main_toolpanel.Index = 0
  
End

Public Sub refresh_db_tree()
  ' refresh the main tree view
  Dim objects As Collection
  Dim tab As Collection
  Dim o As String
  FMain.main_treeview.Clear
  objects = get_db_objects()
  FMain.main_treeview.Add("Tables", "Tables", Picture.Load("directory.png"))
  For Each tab In objects["tables"]
    FMain.main_treeview.Add("tab_" & tab["table"], tab["table"], Picture.Load(objects["object types"]["tables"]), "Tables")
  Next
  FMain.main_treeview.Add("Views", "Views", Picture.Load("directory.png"))
  For Each tab In objects["views"]
    FMain.main_treeview.Add("viw_" & tab["view"], tab["view"], picture.Load(objects["object types"]["views"]), "Views")
  Next
  FMain.main_treeview.Add("Indices", "Indices", Picture.Load("directory.png"))
  For Each tab In objects["indices"]
    FMain.main_treeview.Add("ind_" & tab["index"], tab["index"], picture.Load(objects["object types"]["indices"]), "Indices")
  Next
  FMain.main_treeview.Add("Functions", "Functions", Picture.Load("directory.png"))
  For Each tab In objects["functions"]
    FMain.main_treeview.Add("fun_" & tab["function"] & "(" & tab["arguments"] & ")", tab["function"] & "(" & tab["arguments"] & ")", picture.Load(objects["object types"]["functions"]), "Functions")
  Next
  FMain.main_treeview.Add("Triggers", "Triggers", Picture.Load("directory.png"))
  For Each tab In objects["triggers"]
    FMain.main_treeview.Add("tri_" & tab["trigger"] & " on " & tab["table"], tab["trigger"] & " on " & tab["table"], picture.Load(objects["object types"]["triggers"]), "Triggers")
  Next
  FMain.main_treeview.Add("Sequences", "Sequences", Picture.Load("directory.png"))
  For Each tab In objects["sequences"]
    FMain.main_treeview.Add("seq_" & tab["sequence"], tab["sequence"], picture.Load(objects["object types"]["sequences"]), "Sequences")
  Next
  FMain.main_treeview.Add("Types", "Types", Picture.Load("directory.png"))
  For Each tab In objects["types"]
    FMain.main_treeview.Add("typ_" & tab["user_type"], tab["user_type"], picture.Load(objects["object types"]["types"]), "Types")
  Next
  ' create Baze object containers
  With FMain.main_treeview
    .Add("Queries", "Queries", Picture.Load("directory.png"))
    .Add("Update queries", "Update queries", Picture.Load("directory.png"), "Queries")
    For Each o In Me.dbobjects["queries"]["update queries"]
      .Add(Me.dbobjects["queries"]["update queries"].key, Me.dbobjects["queries"]["update queries"].key, Picture.Load("query.png"), "Update queries")
    Next
    .Add("Insert queries", "Insert queries", Picture.Load("directory.png"), "Queries")
    For Each o In Me.dbobjects["queries"]["insert queries"]
      .Add(Me.dbobjects["queries"]["insert queries"].key, Me.dbobjects["queries"]["insert queries"].key, Picture.Load("query.png"), "Insert queries")
    Next
    .Add("Delete queries", "Delete queries", Picture.Load("directory.png"), "Queries")
    For Each o In Me.dbobjects["queries"]["delete queries"]
      .Add(Me.dbobjects["queries"]["delete queries"].key, Me.dbobjects["queries"]["delete queries"].key, Picture.Load("query.png"), "Delete queries")
    Next
    .Add("SQL queries", "SQL queries", Picture.Load("directory.png"), "Queries")
   
    For Each o In Me.dbobjects["queries"]["sql queries"]
      .Add(Me.dbobjects["queries"]["sql queries"].key, Me.dbobjects["queries"]["sql queries"].key, Picture.Load("query.png"), "SQL queries")
    Next
    .Add("QBE queries", "QBE queries", Picture.Load("directory.png"), "Queries")
    For Each o In Me.dbobjects["queries"]["qbe queries"]
      .Add(o, o, Picture.Load("query.png"), "QBE queries")
    Next
    .Add("Forms", "Forms", Picture.Load("directory.png"))
    For Each o In Me.dbobjects["forms"]
      .Add(o, o, Picture.Load("query.png"), "Forms")
    Next
    .Add("Scripts", "Scripts", Picture.Load("directory.png"))
    For Each o In Me.dbobjects["scripts"]
      .Add(o, o, Picture.Load("query.png"), "Scripts")
    Next
  End With
 
  
End


Public Sub new_sql_query(ttitle As String, tquery As String, Optional ttype As String)
  ' create new sql query and store it in dbobjects
  If ttype Then
     Me.dbobjects["queries"][ttype][ttitle] = tquery
  Else
     Me.dbobjects["queries"]["sql queries"][ttitle] = tquery
  Endif
  Me.Save()
End

Public Function rewrite_query(query As String) As String
  ' rewrite the query to return distinct column names
  Dim has_asterisk As String[]
  Dim defined_limit As String[]
  Dim replace_limit As String
  Dim query_copy As String
  Dim res As Result
  Dim rfield As ResultField
  Dim with_string As String
  Dim i As Integer
  has_asterisk = XSBEngine.FindAll(query, "(?i)select (.*?[\\*].*?) from", 1)
  If has_asterisk.Count > 0 Then
    query_copy = query
    defined_limit = XSBEngine.FindAll(query, "(?i)(limit +[0-9]+)", 1)
    If defined_limit.Count > 0 Then
      For Each replace_limit In defined_limit
        query = Replace(query, replace_limit, "LIMIT 1")
      Next
    Else
      query &= " LIMIT 1"
    Endif
    res = con.Exec(query)
    For Each res
      For Each rfield In res.Fields
        original.Push(rfield.name)
      Next
    Next
    If original.Count = 0 Then
      Return query_copy
    Endif
    with_string = "WITH query("
    For i = 0 To original.Max
      with_string &= "a" & Str(i) & ", "
    Next
    with_string = Left$(with_string, -2) & ") AS (" & query_copy & ") SELECT * FROM query"
    Return with_string
  Else
    Return query
  Endif
End

Public Sub rename_table(old_name As String, new_name As String)
  ' rename a table in the database
  execute("ALTER TABLE \"" & FMain.pg_escape(old_name) & "\" RENAME TO \"" & FMain.pg_escape(new_name) & "\"")
End




